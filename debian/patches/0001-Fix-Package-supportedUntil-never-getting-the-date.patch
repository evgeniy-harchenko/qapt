From 82d06c9da5952f40a07dfbbc4257fd35837b288c Mon Sep 17 00:00:00 2001
From: Carlo Vanini <silhusk@gmail.com>
Date: Fri, 21 Dec 2018 21:18:31 +0100
Origin: https://cgit.kde.org/libqapt.git/commit/?id=82d06c9da5952f40a07dfbbc4257fd35837b288c
Subject: [PATCH] Fix Package::supportedUntil never getting the date

Summary:
We were expecting to find a Release file, but package archives have
moved from Release files to InRelease files, which have inlined GPG
signature.

Moreover, we try to get the release date from `distro-info/ubuntu.csv` and prefer it over the [In]Release file.
We get the release Id and Codename from `/etc/os-release`, which is more modern than `lsb-release`.

Reviewers: sitter

Reviewed By: sitter

Differential Revision: https://phabricator.kde.org/D13662
---
 CMakeLists.txt  |   2 +-
 src/backend.cpp | 116 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/backend.h   |  13 ++++++
 src/package.cpp |  80 ++-------------------------------
 src/package.h   |   3 +-
 5 files changed, 135 insertions(+), 79 deletions(-)

--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -26,7 +26,7 @@ include(ECMGeneratePriFile) # This needs
 # Turn exceptions on
 kde_enable_exceptions()
 
-set(REQUIRED_QT_VERSION 5.2.0) # Used in QAptConfig
+set(REQUIRED_QT_VERSION 5.8.0) # Used in QAptConfig
 find_package(Qt5 ${REQUIRED_QT_VERSION} CONFIG REQUIRED DBus Widgets)
 
 find_package(Xapian REQUIRED)
--- a/src/backend.cpp
+++ b/src/backend.cpp
@@ -31,6 +31,7 @@
 #include <apt-pkg/depcache.h>
 #include <apt-pkg/error.h>
 #include <apt-pkg/fileutl.h>
+#include <apt-pkg/gpgv.h>
 #include <apt-pkg/init.h>
 #include <apt-pkg/policy.h>
 #include <apt-pkg/sourcelist.h>
@@ -85,6 +86,11 @@ public:
     // Relation of an origin and its hostname
     QHash<QString, QString> siteMap;
 
+    // Date when the distribution's release was issued. See Backend::releaseDate()
+    QDateTime releaseDate;
+    QDateTime getReleaseDateFromDistroInfo(const QString &releaseId, const QString &releaseCodename) const;
+    QDateTime getReleaseDateFromArchive(const QString &releaseId, const QString &releaseCodename) const;
+
     // Counts
     int installedCount;
 
@@ -121,6 +127,68 @@ public:
     QApt::FrontendCaps frontendCaps;
 };
 
+QDateTime BackendPrivate::getReleaseDateFromDistroInfo(const QString &releaseId, const QString &releaseCodename) const
+{
+    QDateTime releaseDate;
+    QString line;
+    QStringList split;
+
+    QFile distro_info(QStringLiteral("/usr/share/distro-info/%1.csv").arg(releaseId.toLower()));
+    if (distro_info.open(QFile::ReadOnly)) {
+        QTextStream info_stream(&distro_info);
+        line = info_stream.readLine();
+        split = line.split(QLatin1Char(','));
+        const int codenameColumn = split.indexOf(QStringLiteral("series"));
+        const int releaseColumn = split.indexOf(QStringLiteral("release"));
+        if (codenameColumn == -1 || releaseColumn == -1) {
+            return QDateTime();
+        }
+        do {
+            line = info_stream.readLine();
+            split = line.split(QLatin1Char(','));
+            if (split.value(codenameColumn) == releaseCodename) {
+                releaseDate = QDateTime::fromString(split.value(releaseColumn), Qt::ISODate);
+                releaseDate.setTimeSpec(Qt::UTC);;
+                break;
+            }
+        } while (!line.isNull());
+    }
+    return releaseDate;
+}
+
+QDateTime BackendPrivate::getReleaseDateFromArchive(const QString &releaseId, const QString &releaseCodename) const
+{
+    pkgDepCache *depCache = cache->depCache();
+
+    // We are only interested in `*ubuntu_dists_<codename>_[In]Release`
+    // in order to get the release date. In `<codename>-updates` and
+    // `-security` the Date gets updated throughout the life of the release.
+    pkgCache::RlsFileIterator rls;
+    for (rls = depCache->GetCache().RlsFileBegin(); !rls.end(); ++rls) {
+        if (rls.Origin() == releaseId
+                && rls.Label() == releaseId
+                && rls.Archive() == releaseCodename) {
+
+            FileFd fd;
+            if (!OpenMaybeClearSignedFile(rls.FileName(), fd)) {
+                continue;
+            }
+
+            time_t releaseDate = -1;
+            pkgTagSection sec;
+            pkgTagFile tag(&fd);
+            tag.Step(sec);
+
+            if(!RFC1123StrToTime(sec.FindS("Date").data(), releaseDate)) {
+                continue;
+            }
+
+            return QDateTime::fromSecsSinceEpoch(releaseDate);
+        }
+    }
+    return QDateTime();
+}
+
 bool BackendPrivate::writeSelectionFile(const QString &selectionDocument, const QString &path) const
 {
     QFile file(path);
@@ -245,6 +313,8 @@ bool Backend::reloadCache()
     // Determine which packages are pinned for display purposes
     loadPackagePins();
 
+    loadReleaseDate();
+
     emit cacheReloadFinished();
 
     return true;
@@ -294,6 +364,45 @@ void Backend::loadPackagePins()
     }
 }
 
+void Backend::loadReleaseDate()
+{
+    Q_D(Backend);
+
+    // Reset value in case we are re-loading cache
+    d->releaseDate = QDateTime();
+
+    QString releaseId;
+    QString releaseCodename;
+
+    QFile lsb_release(QLatin1String("/etc/os-release"));
+    if (!lsb_release.open(QFile::ReadOnly)) {
+        // Though really, your system is screwed if this happens...
+        return;
+    }
+
+    QTextStream stream(&lsb_release);
+    QString line;
+    do {
+        line = stream.readLine();
+        QStringList split = line.split(QLatin1Char('='));
+        if (split.size() != 2) {
+            continue;
+        }
+
+        if (split.at(0) == QLatin1String("VERSION_CODENAME")) {
+            releaseCodename = split.at(1);
+        } else if (split.at(0) == QLatin1String("ID")) {
+            releaseId = split.at(1);
+        }
+    } while (!line.isNull());
+
+    d->releaseDate = d->getReleaseDateFromDistroInfo(releaseId, releaseCodename);
+    if (!d->releaseDate.isValid()) {
+        // If we could not find the date in the csv file, we fallback to Apt archive.
+        d->releaseDate = d->getReleaseDateFromArchive(releaseId, releaseCodename);
+    }
+}
+
 QString Backend::initErrorMessage() const
 {
     Q_D(const Backend);
@@ -638,6 +747,13 @@ QString Backend::nativeArchitecture() co
     return d->nativeArch;
 }
 
+QDateTime Backend::releaseDate() const
+{
+    Q_D(const Backend);
+
+    return d->releaseDate;
+}
+
 bool Backend::areChangesMarked() const
 {
     return (toInstallCount() + toRemoveCount());
--- a/src/backend.h
+++ b/src/backend.h
@@ -111,6 +111,18 @@ public:
     QString nativeArchitecture() const;
 
     /**
+     * Returns the date when the distribution release was issued.
+     *
+     * E.g. for Ubuntu 18.04.1 it returns Thu, 26 Apr 2018 23:37:48 UTC.
+     *
+     * @return Distribution release date or invalid QDateTime if could not
+     * be determined.
+     *
+     * @since 3.1
+     */
+    QDateTime releaseDate() const;
+
+    /**
      * Returns whether the undo stack is empty
      */
     bool isUndoStackEmpty() const;
@@ -452,6 +464,7 @@ private:
 
     void setInitError();
     void loadPackagePins();
+    void loadReleaseDate();
 
 Q_SIGNALS:
     /**
--- a/src/package.cpp
+++ b/src/package.cpp
@@ -85,7 +85,6 @@ class PackagePrivate
         bool inUpdatePhaseCalculated;
 
         pkgCache::PkgFileIterator searchPkgFileIter(QLatin1String label, const QString &release) const;
-        QString getReleaseFileForOrigin(QLatin1String label, const QString &release) const;
 
         // Calculate state flags that cannot change
         void initStaticState(const pkgCache::VerIterator &ver, pkgDepCache::StateCache &stateCache);
@@ -119,40 +118,6 @@ pkgCache::PkgFileIterator PackagePrivate
     return found;
 }
 
-QString PackagePrivate::getReleaseFileForOrigin(QLatin1String label, const QString &release) const
-{
-    pkgCache::PkgFileIterator pkg = searchPkgFileIter(label, release);
-
-    // Return empty if no package matches the given label and release
-    if (pkg.end())
-        return QString();
-
-    // Search for the matching meta-index
-    pkgSourceList *list = backend->packageSourceList();
-    pkgIndexFile *index;
-
-    // Return empty if the source list doesn't contain an index for the package
-    if (!list->FindIndex(pkg, index))
-        return QString();
-
-    for (auto I = list->begin(); I != list->end(); ++I) {
-        vector<pkgIndexFile *> *ifv = (*I)->GetIndexFiles();
-        if (find(ifv->begin(), ifv->end(), index) == ifv->end())
-            continue;
-
-        // Construct release file path
-        QString uri = backend->config()->findDirectory("Dir::State::lists")
-                % QString::fromStdString(URItoFileName((*I)->GetURI()))
-                % QLatin1String("dists_")
-                % QString::fromStdString((*I)->GetDist())
-                % QLatin1String("_Release");
-
-        return uri;
-    }
-
-    return QString();
-}
-
 void PackagePrivate::initStaticState(const pkgCache::VerIterator &ver, pkgDepCache::StateCache &stateCache)
 {
     int packageState = 0;
@@ -608,45 +573,8 @@ QDateTime Package::supportedUntil() cons
         return QDateTime();
     }
 
-    QFile lsb_release(QLatin1String("/etc/lsb-release"));
-    if (!lsb_release.open(QFile::ReadOnly)) {
-        // Though really, your system is screwed if this happens...
-        return QDateTime();
-    }
-
-    pkgTagSection sec;
-    time_t releaseDate = -1;
-    QString release;
-
-    QTextStream stream(&lsb_release);
-    QString line;
-    do {
-        line = stream.readLine();
-        QStringList split = line.split(QLatin1Char('='));
-        if (split.size() != 2) {
-            continue;
-        }
-
-        if (split.at(0) == QLatin1String("DISTRIB_CODENAME")) {
-            release = split.at(1);
-        }
-    } while (!line.isNull());
-
-    // Canonical only provides support for Ubuntu, but we don't have to worry
-    // about Debian systems as long as we assume that this function can fail.
-    QString releaseFile = d->getReleaseFileForOrigin(QLatin1String("Ubuntu"), release);
-
-    if(!FileExists(releaseFile.toStdString())) {
-        // happens e.g. when there is no release file and is harmless
-        return QDateTime();
-    }
-
-    // read the relase file
-    FileFd fd(releaseFile.toStdString(), FileFd::ReadOnly);
-    pkgTagFile tag(&fd);
-    tag.Step(sec);
-
-    if(!RFC1123StrToTime(sec.FindS("Date").data(), releaseDate)) {
+    QDateTime releaseDate = d->backend->releaseDate();
+    if (!releaseDate.isValid()) {
         return QDateTime();
     }
 
@@ -665,9 +593,9 @@ QDateTime Package::supportedUntil() cons
     QDateTime supportEnd;
 
     if (unit == QLatin1Char('m')) {
-        supportEnd = QDateTime::fromTime_t(releaseDate).addMonths(supportTime);
+        supportEnd = releaseDate.addMonths(supportTime);
     } else if (unit == QLatin1Char('y')) {
-        supportEnd = QDateTime::fromTime_t(releaseDate).addYears(supportTime);
+        supportEnd = releaseDate.addYears(supportTime);
     }
 
     return supportEnd;
--- a/src/package.h
+++ b/src/package.h
@@ -257,8 +257,7 @@ public:
     * Returns the date when Canonical's support of the package ends.
     *
     * \return The date that the package is supported until. If it is not
-    *         supported now, then it will return an empty QString. The date
-    *         will be localized in the "month year" format.
+    *         supported now, then it will return an invalid date.
     */
     QDateTime supportedUntil() const;
 
